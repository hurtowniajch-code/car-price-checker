import puppeteer, { Browser, Page } from 'puppeteer';
import * as fs from 'fs';
import * as path from 'path';

const PAGE_DELAY_MS = 2000;

function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function slugify(input: string): string {
  return input
    .toLowerCase()
    .trim()
    .replace(/\s+/g, '-')
    .replace(/[^a-z0-9\-]/g, '');
}

/** Strip trailing count like " (1234)" from option text */
function stripCount(text: string): string {
  return text.replace(/\s*\(\d+\)\s*$/, '').trim();
}

async function launchBrowser(): Promise<Browser> {
  return puppeteer.launch({
    headless: true,
    args: [
      '--no-sandbox',
      '--disable-setuid-sandbox',
      '--disable-dev-shm-usage',
      '--disable-gpu',
    ],
  });
}

async function setupPage(browser: Browser): Promise<Page> {
  const page = await browser.newPage();
  await page.setUserAgent(
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36'
  );
  await page.setViewport({ width: 1920, height: 1080 });
  await page.setExtraHTTPHeaders({ 'Accept-Language': 'pl-PL,pl;q=0.9,en;q=0.8' });
  return page;
}

async function dismissCookies(page: Page): Promise<void> {
  try {
    await page.click('#onetrust-accept-btn-handler');
    await delay(500);
  } catch {
    // No consent banner
  }
}

/** Click a dropdown and extract [role="option"] text values */
async function clickDropdownAndExtract(page: Page, placeholderText: string): Promise<string[]> {
  const selector = `input[placeholder*="${placeholderText}"]`;

  try {
    await page.waitForSelector(selector, { timeout: 5000 });
    await page.click(selector);
  } catch {
    return [];
  }

  await delay(2000);

  const options = await page.evaluate(() => {
    const results: string[] = [];
    document.querySelectorAll('[role="option"]').forEach((el) => {
      const text = el.textContent?.trim();
      if (text) results.push(text);
    });
    return results;
  });

  // Filter out "select all" / placeholder options
  return options.filter((t) =>
    t !== 'Wszystkie' && !t.includes('Wybierz') && t !== ''
  );
}

/**
 * Extract all brands from the main page dropdown.
 */
async function extractBrands(page: Page): Promise<string[]> {
  await page.goto('https://www.otomoto.pl/osobowe', { waitUntil: 'networkidle2', timeout: 30000 });
  await dismissCookies(page);
  await delay(1000);

  const rawBrands = await clickDropdownAndExtract(page, 'Marka');

  if (rawBrands.length === 0) {
    await page.screenshot({ path: path.resolve(__dirname, '..', 'debug-brands.png'), fullPage: false });
    throw new Error('Could not find brands. Check debug-brands.png');
  }

  // Strip counts: "BMW (16344)" -> "BMW"
  const brands = [...new Set(rawBrands.map(stripCount))].filter(Boolean);
  console.log(`[Brands] Found ${brands.length} brands`);
  return brands;
}

/**
 * Extract models for a brand by navigating to its page and clicking the model dropdown.
 */
async function extractModelsForBrand(page: Page, brand: string): Promise<string[]> {
  const brandSlug = slugify(brand);
  const url = `https://www.otomoto.pl/osobowe/${brandSlug}`;

  try {
    await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
  } catch {
    try {
      await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 15000 });
      await delay(3000);
    } catch {
      console.log(`  Failed to load page for ${brand}`);
      return [];
    }
  }

  const rawModels = await clickDropdownAndExtract(page, 'Model');

  // Strip counts and clean: "Seria 3 (3042)" -> "Seria 3", filter out "Inny"
  const models = [...new Set(
    rawModels
      .map(stripCount)
      .filter((m) => m && m !== 'Inny')
  )].sort((a, b) => a.localeCompare(b, 'pl'));

  return models;
}

function generateOutputFile(brandsModels: Record<string, string[]>): string {
  const sortedBrands = Object.keys(brandsModels).sort((a, b) => a.localeCompare(b, 'pl'));

  const entries = sortedBrands.map((brand) => {
    const models = brandsModels[brand];
    const modelsStr = models.map((m) => JSON.stringify(m)).join(', ');
    return `  ${JSON.stringify(brand)}: [${modelsStr}]`;
  });

  return `// Brand → Models mapping (using otomoto.pl Polish names for URL compatibility)
// Auto-generated by scripts/scrape-brands.ts on ${new Date().toISOString()}
const BRANDS_MODELS = {
${entries.join(',\n')}
};

// Build reverse mapping: model → brand (for auto-fill when model selected without brand)
const MODEL_TO_BRAND = {};
for (const [brand, models] of Object.entries(BRANDS_MODELS)) {
  for (const model of models) {
    const key = model.toLowerCase();
    // If model name is unique, map directly. If duplicate, store first match.
    if (!MODEL_TO_BRAND[key]) {
      MODEL_TO_BRAND[key] = brand;
    }
  }
}

// Get sorted list of all brands
const ALL_BRANDS = Object.keys(BRANDS_MODELS).sort((a, b) => a.localeCompare(b, 'pl'));

// Get flat list of all models with their brands (for "all models" dropdown)
const ALL_MODELS = [];
for (const [brand, models] of Object.entries(BRANDS_MODELS)) {
  for (const model of models) {
    ALL_MODELS.push({ brand, model });
  }
}
ALL_MODELS.sort((a, b) => a.model.localeCompare(b.model, 'pl'));
`;
}

async function main(): Promise<void> {
  console.log('=== Otomoto Brand & Model Scraper ===\n');

  const browser = await launchBrowser();

  try {
    const page = await setupPage(browser);

    // Step 1: Get all brands
    console.log('[Step 1] Extracting brands from otomoto.pl...');
    const brands = await extractBrands(page);

    if (brands.length === 0) {
      throw new Error('No brands found.');
    }

    console.log(`\n[Step 2] Extracting models for ${brands.length} brands...\n`);

    const brandsModels: Record<string, string[]> = {};
    let failures = 0;

    for (let i = 0; i < brands.length; i++) {
      const brand = brands[i];
      console.log(`[${i + 1}/${brands.length}] ${brand}...`);

      const models = await extractModelsForBrand(page, brand);
      if (models.length > 0) {
        brandsModels[brand] = models;
        console.log(`  → ${models.length} models`);
      } else {
        console.log(`  → No models found (skipping)`);
        failures++;
      }

      // Polite delay
      if (i < brands.length - 1) {
        await delay(PAGE_DELAY_MS + Math.random() * 1000);
      }
    }

    await page.close();

    // Step 3: Write output
    console.log(`\n[Step 3] Writing output...`);
    const outputPath = path.resolve(__dirname, '..', 'public', 'js', 'brands-models.js');
    const content = generateOutputFile(brandsModels);
    fs.writeFileSync(outputPath, content, 'utf8');

    console.log(`\n=== Done! ===`);
    console.log(`Brands: ${Object.keys(brandsModels).length}`);
    console.log(`Total models: ${Object.values(brandsModels).reduce((sum, m) => sum + m.length, 0)}`);
    if (failures > 0) {
      console.log(`Brands with no models (skipped): ${failures}`);
    }
    console.log(`Output: ${outputPath}`);

  } finally {
    await browser.close();
  }
}

main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});
